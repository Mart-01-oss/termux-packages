--- a/completion.c
+++ b/completion.c
@@ -41,7 +41,7 @@
 /* Tell the GNU Readline library how to complete.  We want to try to complete
  on command names if this is the first word in the line, or on filenames
  if not. */
-void	initialize_readline()
+void	initialize_readline(void)
 {
 #ifdef DEBUG
    printf("Using readline library version: %s\n", rl_library_version);
@@ -53,7 +53,7 @@
     so that if zssh_completion() fails nothing is completed */
    rl_completion_entry_function = fake_generator;
    /* Tell the completer that we want a crack first. */
-   rl_attempted_completion_function = (CPPFunction *) zssh_completion;
+   rl_attempted_completion_function = zssh_completion;
    
 }
 
@@ -62,10 +62,7 @@
  the word to complete.  We can use the entire contents of rl_line_buffer
  in case we want to do some simple parsing.  Return the array of matches,
  or NULL if there aren't any. */
-char		**zssh_completion(text, start, end)
-char		*text;
-int		start;
-int		end;
+char		**zssh_completion(const char *text, int start, int end)
 {
    char		**matches;
    
@@ -89,9 +86,7 @@
 /* Generator function for command completion.  STATE lets us know whether
  to start from scratch; without any state (i.e. STATE == 0), then we
  start at the top of the list. */
-char		*command_generator(text, state)
-const char	*text;
-int		state;
+char		*command_generator(const char *text, int state)
 {
    static int	list_index, len;
    char		*name;
@@ -154,9 +149,7 @@
 }
 #endif /* 0 */
 
-char			*fake_generator(text, state)
-const char		*text;
-int			state;
+char			*fake_generator(const char *text, int state)
 {
    return (0);
 }
